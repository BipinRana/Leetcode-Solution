# LeetCode Roadmap for Google Software Engineering Intern (AI/ML Focus)

This roadmap is designed to prepare for a Google software engineering intern role with an AI/ML focus. It covers essential topics and curated LeetCode problems, progressing from easy to hard, to build problem-solving skills relevant to algorithmic challenges in AI/ML systems.

## 1. Arrays and Hashing
Arrays and hash tables are fundamental for data manipulation and efficient lookups, often used in ML data preprocessing and feature engineering.

- **Easy**:
  - Two Sum (Problem 1): Find two numbers in an array that add up to a target sum.
  - Contains Duplicate (Problem 217): Check if an array contains duplicate elements.
  - Valid Anagram (Problem 242): Determine if two strings are anagrams using a hash map.

- **Medium**:
  - Group Anagrams (Problem 49): Group a list of strings by their anagrams.
  - Top K Frequent Elements (Problem 347): Find the k most frequent elements in an array.
  - Longest Consecutive Sequence (Problem 128): Find the longest sequence of consecutive numbers in an unsorted array.

- **Hard**:
  - Insert Delete GetRandom O(1) (Problem 380): Implement a data structure with O(1) insert, delete, and random access.
  - Minimum Window Substring (Problem 76): Find the smallest substring containing all characters of a given string.

## 2. Two Pointers
Two-pointer techniques are useful for optimizing array and string problems, often encountered in ML data processing tasks.

- **Easy**:
  - Valid Palindrome (Problem 125): Check if a string is a palindrome, ignoring non-alphanumeric characters.
  - Move Zeroes (Problem 283): Move all zeros to the end of an array while maintaining the relative order of non-zero elements.

- **Medium**:
  - 3Sum (Problem 15): Find all unique triplets in an array that sum to zero.
  - Container With Most Water (Problem 11): Find two lines that together hold the maximum amount of water.

- **Hard**:
  - Trapping Rain Water (Problem 42): Calculate the amount of water trapped between bars of varying heights.

## 3. Sliding Window
Sliding window techniques are key for problems involving substrings or subarrays, relevant for sequence modeling in AI.

- **Easy**:
  - Best Time to Buy and Sell Stock (Problem 121): Find the maximum profit from a single buy and sell transaction.

- **Medium**:
  - Longest Substring Without Repeating Characters (Problem 3): Find the length of the longest substring without repeating characters.
  - Permutation in String (Problem 567): Check if one string is a permutation of a substring of another.

- **Hard**:
  - Sliding Window Maximum (Problem 239): Find the maximum element in each k-sized window of an array.

## 4. Stack
Stacks are useful for parsing and backtracking, which can appear in ML model interpretation or preprocessing.

- **Easy**:
  - Valid Parentheses (Problem 20): Check if a string of parentheses is valid.

- **Medium**:
  - Evaluate Reverse Polish Notation (Problem 150): Evaluate the value of an arithmetic expression in Reverse Polish Notation.
  - Daily Temperatures (Problem 739): Find the number of days until a warmer temperature occurs.

- **Hard**:
  - Largest Rectangle in Histogram (Problem 84): Find the largest rectangular area in a histogram.

## 5. Binary Search
Binary search is critical for optimization problems, often used in ML for hyperparameter tuning or searching sorted data.

- **Easy**:
  - Binary Search (Problem 704): Implement binary search on a sorted array.

- **Medium**:
  - Search in Rotated Sorted Array (Problem 33): Search for a target in a rotated sorted array.
  - Find Minimum in Rotated Sorted Array (Problem 153): Find the minimum element in a rotated sorted array.

- **Hard**:
  - Median of Two Sorted Arrays (Problem 4): Find the median of two sorted arrays in O(log(min(m,n))) time.

## 6. Linked Lists
Linked lists are foundational for understanding data structures and can appear in ML pipeline implementations.

- **Easy**:
  - Merge Two Sorted Lists (Problem 21): Merge two sorted linked lists.
  - Reverse Linked List (Problem 206): Reverse a singly linked list.

- **Medium**:
  - Add Two Numbers (Problem 2): Add two numbers represented as linked lists.
  - Remove Nth Node From End of List (Problem 19): Remove the nth node from the end of a linked list.

- **Hard**:
  - Merge k Sorted Lists (Problem 23): Merge k sorted linked lists into one sorted list.

## 7. Trees
Trees are essential for hierarchical data structures, relevant for decision trees and neural network architectures in AI/ML.

- **Easy**:
  - Maximum Depth of Binary Tree (Problem 104): Find the maximum depth of a binary tree.
  - Same Tree (Problem 100): Check if two binary trees are identical.

- **Medium**:
  - Binary Tree Level Order Traversal (Problem 102): Traverse a binary tree level by level.
  - Construct Binary Tree from Preorder and Inorder Traversal (Problem 105): Build a binary tree from preorder and inorder traversals.

- **Hard**:
  - Binary Tree Maximum Path Sum (Problem 124): Find the maximum path sum in a binary tree.

## 8. Graphs
Graphs are critical for AI/ML tasks like network analysis, recommendation systems, and graph-based neural networks.

- **Easy**:
  - Find if Path Exists in Graph (Problem 1971): Check if a path exists between two nodes in an undirected graph.

- **Medium**:
  - Number of Islands (Problem 200): Count the number of islands in a 2D grid.
  - Course Schedule (Problem 207): Determine if a course schedule is possible given prerequisites.

- **Hard**:
  - Word Ladder (Problem 127): Find the shortest transformation sequence from one word to another.
  - Alien Dictionary (Problem 269): Determine the order of characters in an alien language.

## 9. Dynamic Programming
Dynamic programming is crucial for optimization problems, widely used in ML algorithms like reinforcement learning.

- **Easy**:
  - Climbing Stairs (Problem 70): Find the number of ways to climb n stairs.

- **Medium**:
  - House Robber (Problem 198): Maximize the amount robbed without robbing adjacent houses.
  - Coin Change (Problem 322): Find the minimum number of coins to make a given amount.

- **Hard**:
  - Longest Increasing Subsequence (Problem 300): Find the length of the longest increasing subsequence.
  - Word Break II (Problem 140): Break a string into a space-separated sequence of dictionary words.

## 10. Math and Bit Manipulation
Math and bit manipulation are useful for low-level optimizations in ML model implementations.

- **Easy**:
  - Missing Number (Problem 268): Find the missing number in an array of 0 to n.
  - Power of Two (Problem 231): Check if a number is a power of two.

- **Medium**:
  - Single Number (Problem 136): Find the number that appears exactly once in an array.
  - Divide Two Integers (Problem 29): Divide two integers without using multiplication or division.

- **Hard**:
  - Reverse Bits (Problem 190): Reverse the bits of a 32-bit unsigned integer.

## Tips for Preparation
- **Practice Strategy**: Start with easy problems to build confidence, then tackle medium and hard problems. Aim to solve 2-3 problems per topic daily.
- **Time Management**: Spend 20-30 minutes per problem before checking solutions to develop problem-solving intuition.
- **AI/ML Relevance**: Focus on problems involving optimization (e.g., dynamic programming, graphs) and data manipulation (e.g., arrays, hash tables), as these align with ML tasks like model training and data preprocessing.
- **Mock Interviews**: Use LeetCode’s mock interview feature or platforms like Pramp to simulate Google’s coding interviews.
- **Review**: Revisit problems you struggled with to reinforce concepts.

This roadmap covers approximately 40 problems, balanced across difficulty levels and topics, to prepare you for Google’s technical interviews while emphasizing AI/ML-relevant skills.